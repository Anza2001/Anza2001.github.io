<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32gl-A.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16gl-A.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="AFL二三事3——by有毒  搬砖again。 前言本文主要阅读AFL的 fuzzer 部分，学习其核心内容。">
<meta property="og:type" content="website">
<meta property="og:title" content="AFL源码阅读搬运3">
<meta property="og:url" content="http://example.com/unfinished/AFL-read3.html">
<meta property="og:site_name" content="Anza | 学习记录">
<meta property="og:description" content="AFL二三事3——by有毒  搬砖again。 前言本文主要阅读AFL的 fuzzer 部分，学习其核心内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://c2.im5i.com/2022/01/10/UyW8j.png">
<meta property="og:image" content="https://c2.im5i.com/2022/01/10/Uy2CS.png">
<meta property="article:published_time" content="2022-01-10T01:47:39.000Z">
<meta property="article:modified_time" content="2022-01-10T03:15:13.954Z">
<meta property="article:author" content="Anza">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://c2.im5i.com/2022/01/10/UyW8j.png">

<link rel="canonical" href="http://example.com/unfinished/AFL-read3">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>AFL源码阅读搬运3 | Anza | 学习记录
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Anza | 学习记录" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Anza | 学习记录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">AFL源码阅读搬运3
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269537.htm">AFL二三事3——by有毒</a></p>
</blockquote>
<p>搬砖again。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要阅读AFL的 fuzzer 部分，学习其核心内容。</p>
<span id="more"></span>

<h2 id="AFL的fuzzer——afl-fuzz-c"><a href="#AFL的fuzzer——afl-fuzz-c" class="headerlink" title="AFL的fuzzer——afl-fuzz.c"></a>AFL的fuzzer——afl-fuzz.c</h2><p>AFL中最重要的部分便是fuzzer的实现部分——<code>afl_fuzz.c</code> ，其主要作用是通过不断变异测试用例来影响程序的执行路径。该文件代码量在8000行左右，处于篇幅原因，我们不会对每一个函数进行源码级分析，而是按照功能划分，介绍其中的核心函数。该文件属于AFL整个项目的核心中的核心，强烈建议通读该文件。</p>
<p>在介绍源码的同时，会穿插AFL的整体运行过程和设计思路，辅助理解源码的设计思路。</p>
<p>在功能上，可以总体上分为3部分：</p>
<ol>
<li>初始配置：进行fuzz环境配置相关工作</li>
<li>fuzz执行：fuzz的主循环过程</li>
<li>变异策略：测试用例的变异过程和方式</li>
</ol>
<h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><ul>
<li><p>第一个while循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">  ... ...</span><br></pre></td></tr></table></figure>

<p>该循环主要通过 <code>getopt</code> 获取各种<strong>环境配置、选项参数</strong>等。</p>
</li>
<li><p>setup_signal_handlers 函数</p>
<p>调用 <code>sigaction</code> ，注册信号处理函数，设置信号句柄。具体的信号内容如下：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP/SIGINT/SIGTERM</td>
<td>处理各种“stop”情况</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>处理超时的情况</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>处理窗口大小</td>
</tr>
<tr>
<td>SIGUSER1</td>
<td>用户自定义信号，这里定义为skip request</td>
</tr>
<tr>
<td>SIGSTP/SIGPIPE</td>
<td>不是很重要的一些信号，可以不用关心</td>
</tr>
</tbody></table>
</li>
<li><p>check_asan_opts 函数</p>
<p>读取环境变量 <code>ASAN_OPTIONS</code> 和 <code>MSAN_OPTIONS</code>，做一些必要性检查。</p>
</li>
<li><p>fix_up_sync 函数</p>
<p>如果通过 <code>-M</code>或者<code>-S</code>指定了 <code>sync_id</code>，则更新 <code>out_dir</code> 和 <code>sync_dir</code> 的值：设置 <code>sync_dir</code> 的值为 <code>out_dir</code>，设置 <code>out_dir</code> 的值为<code>out_dir/sync_id</code>。</p>
</li>
<li><p>save_cmdline 函数</p>
<p>copy当前命令行参数，保存。</p>
</li>
<li><p>check_if_tty 函数</p>
<p>检查是否在tty终端上面运行：读取环境变量 <code>AFL_NO_UI</code> ，如果存在，设置 <code>not_on_tty</code> 为1，并返回；通过 <code>ioctl</code> 读取window size，如果报错为 <code>ENOTTY</code>，表示当前不在一个tty终端运行，设置 <code>not_on_tty</code>。</p>
</li>
<li><p>几个CPU检查相关的函数</p>
<ul>
<li><code>static void get_core_count(void)  get_core_count()</code>：获取核心数量</li>
<li><code>check_crash_handling()</code>：确保核心转储不会进入程序</li>
<li><code>check_cpu_governor()</code>：检查CPU管理者</li>
</ul>
</li>
<li><p>setup_shm 函数</p>
<p>该函数用于<strong>设置共享内存</strong>和 <code>virgin_bits</code>，属于比较重要的函数，这里我们结合源码来解析一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"> </span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) </span><br><span class="line">      <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="comment">// 如果 in_bitmap 为空，调用 memset 初始化数组 virgin_bits[MAP_SIZE] 的每个元素的值为 ‘255’。</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE); <span class="comment">// 调用 memset 初始化数组 virgin_tmout[MAP_SIZE] 的每个元素的值为 ‘255’。</span></span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE); <span class="comment">// 调用 memset 初始化数组 virgin_crash[MAP_SIZE] 的每个元素的值为 ‘255’。</span></span><br><span class="line"> </span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line">  <span class="comment">// 调用 shmget 函数分配一块共享内存，并将返回的共享内存标识符保存到 shm_id</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  atexit(remove_shm); <span class="comment">// 注册 atexit handler 为 remove_shm</span></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id); <span class="comment">// 创建字符串 shm_str</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) </span><br><span class="line">      setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果不是dumb_mode，设置环境变量 SHM_ENV_VAR 的值为 shm_str</span></span><br><span class="line"> </span><br><span class="line">  ck_free(shm_str);</span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 设置 trace_bits 并初始化为0</span></span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) </span><br><span class="line">      PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过 <code>trace_bits</code> 和 <code>virgin_bits</code> 两个 bitmap 来分别记录当前的 tuple 信息及整体 tuple 信息，其中 <code>trace_bits</code> 位于共享内存上，便于进行进程间通信。通过 <code>virgin_tmout</code> 和 <code>virgin_crash</code> 两个 bitmap 来记录 fuzz 过程中出现的所有目标程序超时以及崩溃的 tuple 信息。</p>
</li>
<li><p>setup_dirs_fds 函数</p>
<p>该函数用于<strong>准备输出文件夹和文件描述符</strong>，结合源码进行解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_dirs_fds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  u8* tmp;</span><br><span class="line">  s32 fd;</span><br><span class="line"> </span><br><span class="line">  ACTF(<span class="string">&quot;Setting up output directories...&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (sync_id &amp;&amp; mkdir(sync_dir, <span class="number">0700</span>) &amp;&amp; errno != EEXIST)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line">  <span class="comment">/* 如果sync_id，且创建sync_dir文件夹并设置权限为0700，如果报错单errno不是 EEXIST ，抛出异常 */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mkdir(out_dir, <span class="number">0700</span>)) &#123; <span class="comment">// 创建out_dir， 权限为0700</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) </span><br><span class="line">        PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line">    maybe_delete_out_dir();</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (in_place_resume) <span class="comment">// 创建成功</span></span><br><span class="line">      FATAL(<span class="string">&quot;Resume attempted but old output directory not found&quot;</span>);</span><br><span class="line">    out_dir_fd = open(out_dir, O_RDONLY); <span class="comment">// 以只读模式打开，返回fd：out_dir_fd</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __sun</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span> || flock(out_dir_fd, LOCK_EX | LOCK_NB))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to flock() output directory.&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Queue directory for any starting &amp; discovered paths. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp); </span><br><span class="line">  <span class="comment">// 创建 out_dir/queue 文件夹，权限为0700</span></span><br><span class="line"></span><br><span class="line">  ck_free(tmp); </span><br><span class="line">  <span class="comment">/* Top-level directory for queue metadata used for session</span></span><br><span class="line"><span class="comment">     resume and related tasks. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/&quot;</span>, out_dir); </span><br><span class="line">  <span class="comment">// 创建 out_dir/queue/.state 文件夹，用于保存session resume 和相关tasks的队列元数据。</span></span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Directory for flagging queue entries that went through</span></span><br><span class="line"><span class="comment">     deterministic fuzzing in the past. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Directory with the auto-selected dictionary entries. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The set of paths currently deemed redundant. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The set of paths showing variable behavior. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Sync directory for keeping track of cooperating fuzzers. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line"> </span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/.synced/&quot;</span>, out_dir);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>) &amp;&amp; (!in_place_resume || errno != EEXIST))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line"> </span><br><span class="line">    ck_free(tmp);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* All recorded crashes. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/crashes&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* All recorded hangs. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/hangs&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Generally useful file descriptors. */</span></span><br><span class="line"> </span><br><span class="line">  dev_null_fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_null_fd &lt; <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to open /dev/null&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  dev_urandom_fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (dev_urandom_fd &lt; <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to open /dev/urandom&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Gnuplot output file. */</span></span><br><span class="line"> </span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/plot_data&quot;</span>, out_dir);</span><br><span class="line">  fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"> </span><br><span class="line">  plot_file = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!plot_file) </span><br><span class="line">      PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">fprintf</span>(plot_file, <span class="string">&quot;# unix_time, cycles_done, cur_path, paths_total, &quot;</span></span><br><span class="line">                     <span class="string">&quot;pending_total, pending_favs, map_size, unique_crashes, &quot;</span></span><br><span class="line">                     <span class="string">&quot;unique_hangs, max_depth, execs_per_sec\n&quot;</span>);</span><br><span class="line">                     <span class="comment">/* ignore errors */</span></span><br></pre></td></tr></table></figure></li>
<li><p>read-testcases 函数</p>
<p>该函数会将 <code>in_dir</code> 目录下的测试用例扫描到 <code>queue</code> 中，并且区分该文件是否为经过确定性变异的input，如果是的话跳过，以节省时间。<br>调用函数 <code>add_to_queue()</code> 将测试用例排成queue队列。该函数会在启动时进行调用。</p>
</li>
<li><p>add_to_queue 函数</p>
<p>该函数主要用于将新的test case添加到队列，初始化 <code>fname</code> 文件名称，增加<code>cur_depth</code> 深度，增加 <code>queued_paths</code> 测试用例数量等。</p>
<p>首先，<code>queue_entry</code> 结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">  u8* fname;                          <span class="comment">/* File name for the test case      */</span></span><br><span class="line">  u32 len;                            <span class="comment">/* Input length                     */</span></span><br><span class="line"> </span><br><span class="line">  u8  cal_failed,                     <span class="comment">/* Calibration failed?              */</span></span><br><span class="line">      trim_done,                      <span class="comment">/* Trimmed?                         */</span></span><br><span class="line">      was_fuzzed,                     <span class="comment">/* Had any fuzzing done yet?        */</span></span><br><span class="line">      passed_det,                     <span class="comment">/* Deterministic stages passed?     */</span></span><br><span class="line">      has_new_cov,                    <span class="comment">/* Triggers new coverage?           */</span></span><br><span class="line">      var_behavior,                   <span class="comment">/* Variable behavior?               */</span></span><br><span class="line">      favored,                        <span class="comment">/* Currently favored?               */</span></span><br><span class="line">      fs_redundant;                   <span class="comment">/* Marked as redundant in the fs?   */</span></span><br><span class="line"> </span><br><span class="line">  u32 bitmap_size,                    <span class="comment">/* Number of bits set in bitmap     */</span></span><br><span class="line">      exec_cksum;                     <span class="comment">/* Checksum of the execution trace  */</span></span><br><span class="line"> </span><br><span class="line">  u64 exec_us,                        <span class="comment">/* Execution time (us)              */</span></span><br><span class="line">      handicap,                       <span class="comment">/* Number of queue cycles behind    */</span></span><br><span class="line">      depth;                          <span class="comment">/* Path depth                       */</span></span><br><span class="line"> </span><br><span class="line">  u8* trace_mini;                     <span class="comment">/* Trace bytes, if kept             */</span></span><br><span class="line">  u32 tc_ref;                         <span class="comment">/* Trace bytes ref count            */</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">next</span>,           /* <span class="title">Next</span> <span class="title">element</span>, <span class="title">if</span> <span class="title">any</span>             */</span></span><br><span class="line"><span class="class">                     *<span class="title">next_100</span>;</span>       <span class="comment">/* 100 elements ahead               */</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在函数内部进行的相关操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append new test case to the queue. */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_to_queue</span><span class="params">(u8* fname, u32 len, u8 passed_det)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> queue_entry));</span><br><span class="line">  <span class="comment">// 通过ck_alloc分配一个 queue_entry 结构体，并进行初始化</span></span><br><span class="line"> </span><br><span class="line">  q-&gt;fname        = fname;</span><br><span class="line">  q-&gt;len          = len;</span><br><span class="line">  q-&gt;depth        = cur_depth + <span class="number">1</span>;</span><br><span class="line">  q-&gt;passed_det   = passed_det;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (q-&gt;depth &gt; max_depth) max_depth = q-&gt;depth;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (queue_top) &#123;</span><br><span class="line">    queue_top-&gt;next = q;</span><br><span class="line">    queue_top = q;</span><br><span class="line">  &#125; <span class="keyword">else</span> </span><br><span class="line">  	q_prev100 = <span class="built_in">queue</span> = queue_top = q;</span><br><span class="line"> </span><br><span class="line">  queued_paths++; <span class="comment">// queue计数器加1</span></span><br><span class="line">  pending_not_fuzzed++; <span class="comment">// 待fuzz的样例计数器加1</span></span><br><span class="line">  cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */</span></span><br><span class="line">  <span class="keyword">if</span> ((queued_paths - <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; queued_paths &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    q_prev100-&gt;next_100 = q;</span><br><span class="line">    q_prev100 = q;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  last_path_time = get_cur_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>pivot_inputs 函数</p>
<p>在输出目录中为输入测试用例创建硬链接。</p>
</li>
<li><p>find_timeout 函数</p>
<p>变量 <code>timeout_given</code> 没有被设置时，会调用到该函数。该函数主要是在没有指定 <code>-t</code> 选项进行 resuming session 时，避免一次次地自动调整超时时间。</p>
</li>
<li><p>detect_file_args</p>
<p>识别参数中是否有“@@”，如果有，则替换为 <code>out_dir/.cur_input</code> ，没有则返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Detect @@ in args. */</span></span><br><span class="line"> </span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">detect_file_args</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  u8* cwd = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!cwd) </span><br><span class="line">      PFATAL(<span class="string">&quot;getcwd() failed&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (argv[i]) &#123;</span><br><span class="line">    u8* aa_loc = <span class="built_in">strstr</span>(argv[i], <span class="string">&quot;@@&quot;</span>); <span class="comment">// 查找@@</span></span><br><span class="line">    <span class="keyword">if</span> (aa_loc) &#123;</span><br><span class="line">      u8 *aa_subst, *n_arg;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* If we don&#x27;t have a file name chosen yet, use a safe default. */</span></span><br><span class="line">      <span class="keyword">if</span> (!out_file)</span><br><span class="line">        out_file = alloc_printf(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Be sure that we&#x27;re always using fully-qualified paths. */</span></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) </span><br><span class="line">          aa_subst = out_file;</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">          aa_subst = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, cwd, out_file);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Construct a replacement argv value. */</span></span><br><span class="line">      *aa_loc = <span class="number">0</span>;</span><br><span class="line">      n_arg = alloc_printf(<span class="string">&quot;%s%s%s&quot;</span>, argv[i], aa_subst, aa_loc + <span class="number">2</span>);</span><br><span class="line">      argv[i] = n_arg;</span><br><span class="line">      *aa_loc = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) </span><br><span class="line">          ck_free(aa_subst); </span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(cwd); <span class="comment">/* not tracked */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>check_binary 函数</p>
<p>检查指定路径<strong>要执行的程序是否存在</strong>，是否为shell脚本，同时检查<strong>elf文件头是否合法及程序是否被插桩</strong>。</p>
</li>
</ul>
<h3 id="第一遍fuzz"><a href="#第一遍fuzz" class="headerlink" title="第一遍fuzz"></a>第一遍fuzz</h3><ul>
<li><p>检查</p>
<p>调用 <code>get_cur_time()</code> 函数获取开始时间，检查是否处于 <code>qemu_mode</code>。</p>
</li>
<li><p>perform_dry_run 函数</p>
<p>该函数是AFL中的一个关键函数，它会执行 <code>input</code> 文件夹下的预先准备的所有测试用例，生成初始化的 queue 和 bitmap，只对初始输入执行一次。</p>
<p>下面将结合函数源码进行解析（删除部分非关键代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform dry run of all test cases to confirm that the app is working as</span></span><br><span class="line"><span class="comment">   expected. This is done only for the initial inputs, and only once. */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">perform_dry_run</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> <span class="built_in">queue</span>; <span class="comment">// 创建queue_entry结构体</span></span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>); <span class="comment">// 读取环境变量 AFL_SKIP_CRASHES</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (q) &#123; <span class="comment">// 遍历队列</span></span><br><span class="line"> </span><br><span class="line">    u8* use_mem;</span><br><span class="line">    u8  res;</span><br><span class="line">    s32 fd;</span><br><span class="line"> </span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"> </span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname); <span class="comment">// 打开q-&gt;fname，读取到分配的内存中</span></span><br><span class="line"> </span><br><span class="line">    close(fd);</span><br><span class="line"> </span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 调用函数calibrate_case校准测试用例</span></span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST,</span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (res) &#123; <span class="comment">// 判断res的值</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> FAULT_NONE:</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="built_in">queue</span>) </span><br><span class="line">            check_map_coverage(); <span class="comment">// 如果为头结点，调用check_map_coverage评估覆盖率</span></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) </span><br><span class="line">            FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; does *NOT* crash&quot;</span>, fn); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line">        <span class="keyword">if</span> (timeout_given) &#123; <span class="comment">// 指定了 -t 选项</span></span><br><span class="line">          <span class="comment">/* The -t nn+ syntax in the command line sets timeout_given to &#x27;2&#x27; and</span></span><br><span class="line"><span class="comment">             instructs afl-fuzz to tolerate but skip queue entries that time</span></span><br><span class="line"><span class="comment">             out. */</span></span><br><span class="line">          <span class="keyword">if</span> (timeout_given &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            WARNF(<span class="string">&quot;Test case results in a timeout (skipping)&quot;</span>);</span><br><span class="line">            q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">            cal_failures++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          SAYF(... ...);</span><br><span class="line">          FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          SAYF(... ...);</span><br><span class="line">          FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> FAULT_CRASH: </span><br><span class="line">        <span class="keyword">if</span> (crash_mode) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (skip_crashes) &#123;</span><br><span class="line">          WARNF(<span class="string">&quot;Test case results in a crash (skipping)&quot;</span>);</span><br><span class="line">          q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mem_limit) &#123; <span class="comment">// 建议增加内存</span></span><br><span class="line">          SAYF(... ...);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          SAYF(... ...);</span><br><span class="line">        &#125;</span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a crash&quot;</span>, fn);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line">        FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> FAULT_NOINST: <span class="comment">// 测试用例运行没有路径信息</span></span><br><span class="line">        FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">case</span> FAULT_NOBITS:  <span class="comment">// 没有出现新路径，判定为无效路径</span></span><br><span class="line">        useless_at_start++;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!in_bitmap &amp;&amp; !shuffle_queue)</span><br><span class="line">          WARNF(<span class="string">&quot;No new instrumentation output, test case may be useless.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior) </span><br><span class="line">        WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>); </span><br><span class="line">    q = q-&gt;next; <span class="comment">// 读取下一个queue</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (cal_failures) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">      FATAL(<span class="string">&quot;All test cases time out%s, giving up!&quot;</span>,</span><br><span class="line">            skip_crashes ? <span class="string">&quot; or crash&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    WARNF(<span class="string">&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;</span>, cal_failures,</span><br><span class="line">          ((<span class="type">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">          skip_crashes ? <span class="string">&quot; or crashes&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cal_failures * <span class="number">5</span> &gt; queued_paths)</span><br><span class="line">      WARNF(cLRD <span class="string">&quot;High percentage of rejected test cases, check settings!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结以上流程：</p>
<ol>
<li>进入 <code>while</code> 循环，遍历 <code>input</code> 队列，从队列中取出 <code>q-&gt;fname</code>，读取文件内容到分配的内存中，然后关闭文件；</li>
<li>调用 <code>calibrate_case</code> 函数校准该测试用例；</li>
<li>根据校准的返回值 <code>res</code> ，判断错误类型；</li>
<li>打印错误信息，退出。</li>
</ol>
</li>
<li><p>calibrate_case 函数</p>
<p>该函数同样为AFL的一个关键函数，用于新测试用例的<strong>校准</strong>，在处理输入目录时执行，以便在早期就发现有问题的测试用例，并且在发现新路径时，评估新发现的测试用例的是否可变。该函数在 <code>perform_dry_run</code>，<code>save_if_interesting</code>，<code>fuzz_one</code>，<code>pilot_fuzzing</code>，<code>core_fuzzing</code>函数中均有调用。该函数主要用途是<strong>初始化并启动fork server，多次运行测试用例</strong>，并用 <code>update_bitmap_score</code> <strong>进行初始的byte排序</strong>。</p>
<p>结合源码进行解读如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calibrate a new test case. This is done when processing the input directory</span></span><br><span class="line"><span class="comment">   to warn about flaky or otherwise problematic test cases early on; and when</span></span><br><span class="line"><span class="comment">   new paths are discovered to detect variable behavior and so on. */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem,</span></span><br><span class="line"><span class="params">                         u32 handicap, u8 from_queue)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE]; <span class="comment">// 创建 firts_trace[MAP_SIZE]</span></span><br><span class="line"> </span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">      first_run = (q-&gt;exec_cksum == <span class="number">0</span>); <span class="comment">// 获取执行追踪结果，判断case是否为第一次运行，若为0则表示第一次运行，来自input文件夹</span></span><br><span class="line"> </span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"> </span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name; <span class="comment">// 保存原有 stage_cur, stage_max, stage_name</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span></span><br><span class="line"><span class="comment">     trying to calibrate already-added finds. This helps avoid trouble due</span></span><br><span class="line"><span class="comment">     to intermittent latency. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    <span class="comment">// 如果from_queue为0（表示case不是来自queue）或者resuming_fuzz为1（表示处于resuming sessions）</span></span><br><span class="line">    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>); <span class="comment">// 提升 use_tmout 的值</span></span><br><span class="line"> </span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"> </span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>; <span class="comment">// 设置 stage_name</span></span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES; <span class="comment">// 设置 stage_max，新测试用例的校准周期数</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Make sure the fork server is up before we do anything, and let&#x27;s not</span></span><br><span class="line"><span class="comment">     count its spin-up time toward binary calibration. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_fork server &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_fork <span class="title function_">server</span><span class="params">(argv)</span>; <span class="comment">// 没有运行在dumb_mode，没有禁用fork server，切forksrv_pid为0时，启动fork server</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) &#123; <span class="comment">// 判断是否为新case（如果这个queue不是来自input文件夹）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">    hnb = has_new_bits(virgin_bits);</span><br><span class="line">    <span class="keyword">if</span> (hnb &gt; new_bits) </span><br><span class="line">        new_bits = hnb;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  start_us = get_cur_time_us();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123; <span class="comment">// 开始执行 calibration stage，总计执行 stage_max 轮</span></span><br><span class="line">    u32 cksum;</span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) </span><br><span class="line">        show_stats(); <span class="comment">// queue不是来自input，第一轮calibration stage执行结束，刷新一次展示界面</span></span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line">    fault = run_target(argv, use_tmout);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">       we want to bail out quickly. */</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) </span><br><span class="line">        <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;</span><br><span class="line">      <span class="comment">// 如果 calibration stage第一次运行，且不在dumb_mode，共享内存中没有任何路径</span></span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line">      hnb = has_new_bits(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits) </span><br><span class="line">          new_bits = hnb;</span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123; <span class="comment">// 不等于exec_cksum，表示第一次运行，或在相同参数下，每次执行，cksum不同，表示是一个路径可变的queue</span></span><br><span class="line"> </span><br><span class="line">        u32 i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line">                    <span class="comment">// 从0到MAP_SIZE进行遍历， first_trace[i] != trace_bits[i]，表示发现了可变queue</span></span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">        q-&gt;exec_cksum = cksum; <span class="comment">// q-&gt;exec_cksum=0，表示第一次执行queue，则设置计算出来的本次执行的cksum</span></span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  stop_us = get_cur_time_us();</span><br><span class="line"> </span><br><span class="line">  total_cal_us     += stop_us - start_us;  <span class="comment">// 保存所有轮次的总执行时间</span></span><br><span class="line">  total_cal_cycles += stage_max; <span class="comment">// 保存总轮次</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* OK, let&#x27;s collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">     This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"> </span><br><span class="line">  q-&gt;exec_us     = (stop_us - start_us) / stage_max; <span class="comment">// 单次执行时间的平均值</span></span><br><span class="line">  q-&gt;bitmap_size = count_bytes(trace_bits); <span class="comment">// 最后一次执行所覆盖的路径数</span></span><br><span class="line">  q-&gt;handicap    = handicap;</span><br><span class="line">  q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size; <span class="comment">// 加上queue所覆盖的路径数</span></span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"> </span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* If this case didn&#x27;t result in new output from the instrumentation, tell</span></span><br><span class="line"><span class="comment">     parent. This is a non-critical problem, but something to warn the user</span></span><br><span class="line"><span class="comment">     about. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) </span><br><span class="line">      fault = FAULT_NOBITS;</span><br><span class="line"> </span><br><span class="line">abort_calibration:</span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123; <span class="comment">// queue是可变路径</span></span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 恢复之前的stage值</span></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!first_run) </span><br><span class="line">      show_stats();</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结以上过程如下：</p>
<ol>
<li>进行参数设置，包括当前阶段 <code>stage_cur</code>，阶段名称 <code>stage_name</code>，新比特 <code>new_bit</code> 等初始化;</li>
<li>参数 <code>from_queue</code>，判断case是否在队列中，且是否处于resuming session， 以此设置时间延迟。testcase参数 <code>q-&gt;cal_failed</code> 加1， 是否校准失败参数加1；</li>
<li>判断是否已经启动fork server ，调用函数 <code>init_fork server()</code> ；</li>
<li>拷贝 <code>trace_bits</code> 到 <code>first_trace</code> ，调用 <code>get_cur_time_us()</code> 获取开始时间 <code>start_us</code>；</li>
<li>进入loop循环，该loop循环多次执行testcase，循环次数为8次或者3次；</li>
<li>调用 <code>write_to_testcase</code> 将修改后的数据写入文件进行测试。如果 <code>use_stdin</code> 被清除，取消旧文件链接并创建一个新文件。否则，缩短<code>prog_in_fd</code> ；</li>
<li>调用 <code>run_target</code> 通知fork server可以开始fork并fuzz；</li>
<li>调用 <code>hash32</code> 校验此次运行的 <code>trace_bits</code>，检查是否出现新的情况；</li>
<li>将本次运行的出现 <code>trace_bits</code> 哈希和本次 testcase的 <code>q-&gt;exec_cksum</code>对比。如果发现不同，则调用 <code>has_new_bits</code>函数和总表<code>virgin_bits</code> 对比；</li>
<li>判断 <code>q-&gt;exec_cksum</code> 是否为0，不为0说明不是第一次执行。后面运行如果和前面第一次 <code>trace_bits</code> 结果不同，则需要多运行几次；</li>
<li>loop循环结束；</li>
<li>收集一些关于测试用例性能的统计数据。比如执行时间延迟，校准错误，bitmap大小等等；</li>
<li>调用 <code>update_bitmap_score()</code> 函数对测试用例的每个byte进行排序，用一个 <code>top_rate[]</code> 维护最佳入口；</li>
<li>如果没有从检测中得到 <code>new_bit</code>，则告诉父进程，这是一个无关紧要的问题，但是需要提醒用户。<br>总结：calibratecase函数到此为止，该函数主要用途是init_fork server；将testcase运行多次；用update_bitmap_score进行初始的byte排序。</li>
</ol>
</li>
<li><p>init_forkserve 函数</p>
<p>AFL的fork server机制避免了多次执行 <code>execve()</code> 函数的多次调用，只需要调用一次然后通过管道发送命令即可。该函数主要用于启动APP和它的fork server。</p>
<p>结合源码梳理一下函数流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> init_fork <span class="title function_">server</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"> </span><br><span class="line">  ACTF(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) </span><br><span class="line">      PFATAL(<span class="string">&quot;pipe() failed&quot;</span>);</span><br><span class="line">  <span class="comment">// 检查 st_pipe 和ctl_pipe，在父子进程间进行管道通信，一个用于传递状态，一个用于传递命令</span></span><br><span class="line"> </span><br><span class="line">  forksrv_pid = fork();</span><br><span class="line">  <span class="comment">// fork进程出一个子进程</span></span><br><span class="line">  <span class="comment">// 如果fork成功，则现在有父子两个进程</span></span><br><span class="line">  <span class="comment">// 此时的父进程为fuzzer，子进程则为目标程序进程，也是将来的fork server</span></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>) </span><br><span class="line">      PFATAL(<span class="string">&quot;fork() failed&quot;</span>); <span class="comment">// fork失败</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 子进程和父进程都会向下执行，通过pid来使父子进程执行不同的代码</span></span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123; <span class="comment">// 子进程执行</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="comment">/* 中间省略针对OpenBSD的特殊处理 */</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建守护进程</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 重定向文件描述符1和2到dev_null_fd</span></span><br><span class="line">    dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">    dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果指定了out_file，则文件描述符0重定向到dev_null_fd，否则重定向到out_fd</span></span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">      dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">      close(out_fd);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="comment">// 设置控制和状态管道，关闭不需要的一些文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">1</span>]);</span><br><span class="line">    close(out_dir_fd);</span><br><span class="line">    close(dev_null_fd);</span><br><span class="line">    close(dev_urandom_fd);</span><br><span class="line">    close(fileno(plot_file));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果没有设置延迟绑定，则进行设置，不使用缺省模式</span></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) </span><br><span class="line">        setenv(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line">    <span class="comment">// 设置环境变量ASAN_OPTIONS，配置ASAN相关</span></span><br><span class="line">    setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MSAN相关</span></span><br><span class="line">    setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 带参数执行目标程序，报错才返回</span></span><br><span class="line"><span class="comment">             execv()会替换原有进程空间为目标程序，所以后续执行的都是目标程序。</span></span><br><span class="line"><span class="comment">             第一个目标程序会进入__afl_maybe_log里的__afl_fork_wait_loop，并充当fork server。</span></span><br><span class="line"><span class="comment">             在整个过程中，每次要fuzz一次目标程序，都会从这个fork server再fork出来一个子进程去fuzz。</span></span><br><span class="line"><span class="comment">             因此可以看作是三段式：fuzzer -&gt; fork server -&gt; target子进程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    execv(target_path, argv);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 告诉父进程执行失败，结束子进程</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Close the unneeded endpoints. */</span></span><br><span class="line"> </span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>]; <span class="comment">// 父进程只能发送命令</span></span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];  <span class="comment">// 父进程只能读取状态</span></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line">    <span class="comment">// 在一定时间内等待fork server启动</span></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>); <span class="comment">// 从管道里读取4字节数据到status</span></span><br><span class="line"> </span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123; <span class="comment">// 以读取的结果判断fork server是否成功启动</span></span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 子进程启动失败的异常处理相关</span></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">   ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们结合fuzzer对该函数的调用来梳理完整的流程如下：</p>
<p><em>启动目标程序进程后，目标程序会运行一个fork server，fuzzer自身并不负责fork子进程，而是通过管道与fork server通信，由fork server来完成fork以及继续执行目标程序的操作</em>。</p>
<img src="https://c2.im5i.com/2022/01/10/UyW8j.png"  />

<p>对于fuzzer和目标程序之间的通信状态我们可以通过下图来梳理：</p>
<p><img src="https://c2.im5i.com/2022/01/10/Uy2CS.png"></p>
<p>结合前面的插桩部分一起来看：</p>
<p>首先，<code>afl-fuzz</code> 会创建两个管道：状态管道和控制管道，然后执行目标程序。此时的目标程序的 <code>main()</code> 函数已经被插桩，程序控制流进入 <code>__afl_maybe_log</code> 中。如果fuzz是第一次执行，则此时的程序就成了fork server们之后的目标程序都由该fork server通过fork生成子进程来运行。fuzz进行过程中，fork server会一直执行fork操作，并将子进程的结束状态通过状态管道传递给 <code>afl-fuzz</code>。</p>
</li>
<li><p>run_target 函数</p>
<p>该函数主要<strong>执行目标应用程序，并进行超时监控，返回状态信息</strong>，被调用的程序会更新 <code>trace_bits[]</code> 。</p>
<p>结合源码进行解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">run_target</span><span class="params">(<span class="type">char</span>** argv, u32 timeout)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">static</span> u32 prev_timed_out = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> u64 exec_ms = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  u32 tb4;</span><br><span class="line">  child_timed_out = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* After this memset, trace_bits[] are effectively volatile, so we</span></span><br><span class="line"><span class="comment">     must prevent any earlier operations from venturing into that</span></span><br><span class="line"><span class="comment">     territory. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE); <span class="comment">// 将trace_bits全部置0，清空共享内存</span></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* If we&#x27;re running in &quot;dumb&quot; mode, we can&#x27;t rely on the fork server</span></span><br><span class="line"><span class="comment">     logic compiled into the target program, so we will just keep calling</span></span><br><span class="line"><span class="comment">     execve(). There is a bit of code duplication between here and</span></span><br><span class="line"><span class="comment">     init_fork server(), but c&#x27;est la vie. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_fork server) &#123; <span class="comment">// 如果是dumb_mode模式且没有fork server</span></span><br><span class="line">    child_pid = fork(); <span class="comment">// 直接fork出一个子进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line">     ... ...</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"> </span><br><span class="line">      setsid();</span><br><span class="line"> </span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        close(out_fd);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */</span></span><br><span class="line"> </span><br><span class="line">      close(dev_null_fd);</span><br><span class="line">      close(out_dir_fd);</span><br><span class="line">      close(dev_urandom_fd);</span><br><span class="line">      close(fileno(plot_file));</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"> </span><br><span class="line">      setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                             <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      execv(target_path, argv); <span class="comment">// 让子进程execv执行目标程序</span></span><br><span class="line">      <span class="comment">/* Use a distinctive bitmap value to tell the parent about execv()</span></span><br><span class="line"><span class="comment">         falling through. */</span></span><br><span class="line">      *(u32*)trace_bits = EXEC_FAIL_SIG; <span class="comment">// execv执行失败，写入 EXEC_FAIL_SIG</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">    s32 res;</span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">       tell it to have at it, and then read back PID. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果并不是处在dumb_mode模式，说明fork server已经启动了，我们只需要进行</span></span><br><span class="line">    <span class="comment">// 控制管道的写和状态管道的读即可</span></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (stop_soon) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (stop_soon) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) </span><br><span class="line">        FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Configure timeout, as requested by user, then wait for child to terminate. */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 配置超时，等待子进程结束</span></span><br><span class="line">  it.it_value.tv_sec = (timeout / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>; </span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_fork server) &#123;</span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) </span><br><span class="line">        PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">    s32 res;</span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (stop_soon) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to communicate with fork server (OOM?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status)) </span><br><span class="line">      child_pid = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  getitimer(ITIMER_REAL, &amp;it);</span><br><span class="line">  exec_ms = (u64) timeout - (it.it_value.tv_sec * <span class="number">1000</span> +</span><br><span class="line">                             it.it_value.tv_usec / <span class="number">1000</span>); <span class="comment">// 计算执行时间</span></span><br><span class="line"> </span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line">  total_execs++;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Any subsequent operations on trace_bits must not be moved by the</span></span><br><span class="line"><span class="comment">     compiler below this point. Past this location, trace_bits[] behave</span></span><br><span class="line"><span class="comment">     very normally and do not have to be treated as volatile. */</span></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line">  tb4 = *(u32*)trace_bits;</span><br><span class="line">  <span class="comment">// 分别执行64和32位下的classify_counts，设置trace_bits所在的mem</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  classify_counts((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"> </span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line">  <span class="comment">/* Report outcome to caller. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) </span><br><span class="line">        <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* A somewhat nasty hack for MSAN, which doesn&#x27;t support abort_on_error and</span></span><br><span class="line"><span class="comment">     must use a special exit code. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR) &#123;</span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_fork server) &amp;&amp; tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* It makes sense to account for the slowest units only if the testcase was run</span></span><br><span class="line"><span class="comment">  under the user defined timeout. */</span></span><br><span class="line">  <span class="keyword">if</span> (!(timeout &gt; exec_tmout) &amp;&amp; (slowest_exec_ms &lt; exec_ms)) &#123;</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>update_bitmap_score 函数</p>
<p>当我们发现一个新路径时，需要判断发现的新路径是否更“favorable”，也就是是否<strong>包含最小的路径集合能遍历到所有bitmap中的位，并在之后的fuzz过程中聚焦在这些路径上</strong>。</p>
<p>以上过程的第一步是为bitmap中的每个字节维护一个 <code>top_rated[]</code> 的列表，这里会计算究竟哪些位置是更“合适”的，该函数主要实现该过程。</p>
<p>结合源码进行解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line">  <span class="comment">// 首先计算case的fav_factor，计算方法是执行时间和样例大小的乘积</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) <span class="comment">// 遍历trace_bits数组</span></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123; <span class="comment">// 不为0，表示已经被覆盖到的路径</span></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123; <span class="comment">// 检查top_rated是否存在</span></span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) </span><br><span class="line">             <span class="keyword">continue</span>; <span class="comment">// 判断哪个计算结果更小</span></span><br><span class="line">         <span class="comment">// 如果top_rated[i]的更小，则代表它的更优，不做处理，继续遍历下一个路径；</span></span><br><span class="line">         <span class="comment">// 如果q的更小，就执行以下代码：</span></span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           ck_free(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"> </span><br><span class="line">       top_rated[i] = q; <span class="comment">// 设置为当前case</span></span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123; <span class="comment">// 为空</span></span><br><span class="line">         q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         minimize_bits(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><ul>
<li><p>主循环之前</p>
<ul>
<li><p>cull_queue 函数</p>
<p>在前面讨论的关于case的 <code>top_rated</code> 的计算中，还有一个机制是检查所有的 <code>top_rated[]</code> 条目，然后顺序获取之前没有遇到过的byte的对比分数低的“获胜者”进行标记，标记至少会维持到下一次运行之前。在所有的fuzz步骤中，“favorable”的条目会获得更多的执行时间。</p>
<p>结合源码分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cull_queue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span>;</span></span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) </span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">// 如果处于dumb模式或者score没有发生变化（top_rated没有发生变化），直接返回</span></span><br><span class="line"> </span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 设置temp_v大小为MAP_SIZE&gt;&gt;3，初始化为0xff，全1，表示还没有被覆盖到，为0表示被覆盖到了。</span></span><br><span class="line"> </span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (q) &#123; <span class="comment">// 进行队列遍历</span></span><br><span class="line">    q-&gt;favored = <span class="number">0</span>; <span class="comment">// 所有元素的favored均设置为0</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// i从0到MAP_SIZE进行迭代，筛选出一组队列条目，它们可以覆盖到所有现在已经覆盖的路径</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 从temp_v中，移除所有属于当前current-entry的byte，也就是这个testcase触发了多少path就给tempv标记上</span></span><br><span class="line">      <span class="keyword">while</span> (j--)</span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) </span><br><span class="line">          pending_favored++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line">  <span class="keyword">while</span> (q) &#123; <span class="comment">// 遍历队列，不是favored的case（冗余的测试用例）被标记成redundant_edges</span></span><br><span class="line">    mark_as_redundant(q, !q-&gt;favored); <span class="comment">// 位置在/queue/.state/redundent_edges中</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据网上公开的一个例子来理解该过程：</p>
<p>现假设有如下tuple和seed信息：</p>
<ul>
<li><strong>tuple</strong>: t0, t1, t2, t3, t4</li>
<li><strong>seed</strong>: s0, s1, s2</li>
<li>初始化 <code>temp_v = [1,1,1,1,1]</code></li>
<li>s1可覆盖t2, t3，s2覆盖t0, t1, t4，并且top_rated[0] = s2，top_rated[2]=s1</li>
</ul>
<p>将按照如下过程进行筛选和判断：</p>
<ol>
<li>首先判断 temp_v[0]=1，说明t0没有被覆盖；</li>
<li>top_rated[0] 存在 (s2) -&gt; 判断s2可以覆盖的范围 -&gt; <code>trace_mini = [1,1,0,0,1]</code>；</li>
<li>更新 <code>temp_v=[0,0,1,1,0]</code>， 标记s2为 “favored”；</li>
<li>继续判断 temp_v[1]=0，说明t1此时已经被覆盖，跳过；</li>
<li>继续判断 temp_v[2]=1，说明t2没有被覆盖；</li>
<li>top_rated[2] 存在 (s1) -&gt; 判断s1可以覆盖的范围 -&gt; <code>trace_mini=[0,0,1,1,0]</code>；</li>
<li>更新 <code>temp_v=[0,0,0,0,0]</code>，标记s1为 “favored”；</li>
<li>此时所有tuple都被覆盖，具备”favored’标记的为s1, s2，过程结束。</li>
</ol>
</li>
<li><p>show_init_stats 函数</p>
<p>进入主循环前的准备工作使用的函数之一，主要作用为在处理输入目录的末尾显示统计信息，警告信息以及硬编码的常量；</p>
</li>
<li><p>find_start_position 函数</p>
<p>进入主循环前的准备工作使用的函数之一，主要作用为在resume时，尝试查找要开始的队列的位置。</p>
</li>
<li><p>write_stats_file 函数</p>
<p>也是准备工作函数之一，主要作用为更新统计信息文件以进行无人值守的监视。</p>
</li>
<li><p>save_auto 函数</p>
<p>该函数主要保存自动生成的extras。</p>
</li>
</ul>
</li>
<li><p>主循环</p>
<p>这里是seed变异的主循环处理过程，我们将结合流程图和源码进行详细解读。</p>
<p>主循环源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> </span><br><span class="line">  u8 skipped_fuzz;</span><br><span class="line">  cull_queue(); <span class="comment">// 调用cull_queue进行队列精简</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!queue_cur) &#123; <span class="comment">// 如果queue_cure为空（所有queue都被执行完一轮）</span></span><br><span class="line">    queue_cycle++; <span class="comment">// 计数器，所有queue执行的轮数</span></span><br><span class="line">    current_entry     = <span class="number">0</span>;</span><br><span class="line">    cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">    queue_cur         = <span class="built_in">queue</span>; <span class="comment">// 准备开始新一轮fuzz</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (seek_to) &#123; <span class="comment">// 如果seek_to不为空</span></span><br><span class="line">      current_entry++;</span><br><span class="line">      seek_to--;</span><br><span class="line">      queue_cur = queue_cur-&gt;next; <span class="comment">// 从seek_to指定的queue项开始执行</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    show_stats(); <span class="comment">// 刷新展示界面</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">      ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (queued_paths == prev_queued) &#123; <span class="comment">// 如果一轮执行后queue中的case数与执行前一样，表示没有发现新的case</span></span><br><span class="line">      <span class="keyword">if</span> (use_splicing) </span><br><span class="line">      	cycles_wo_finds++; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      	use_splicing = <span class="number">1</span>; <span class="comment">// 是否使用splice进行case变异</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    prev_queued = queued_paths;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">      sync_fuzzers(use_argv);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  skipped_fuzz = fuzz_one(use_argv); <span class="comment">// 对queue_cur进行一次测试</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">   <span class="comment">// 如果skipped_fuzz为0且存在sync_id，表示要进行一次sync</span></span><br><span class="line">    <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">      sync_fuzzers(use_argv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) </span><br><span class="line">  	stop_soon = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (stop_soon) </span><br><span class="line">  	<span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">  queue_cur = queue_cur-&gt;next;</span><br><span class="line">  current_entry++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结以上内容，该处该过程整体如下：</p>
<ol>
<li>判断 <code>queue_cur</code> 是否为空，如果是则表示已经完成队列遍历，初始化相关参数，重新开始一轮；</li>
<li>找到queue入口的case，直接跳到该case；</li>
<li>如果一整个队列循环都没新发现，尝试重组策略；</li>
<li>调用关键函数 <code>fuzz_one()</code> 对该case进行fuzz；</li>
<li>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行“deterministic fuzzing”了。如果用户不停止AFL，seed文件将会一遍遍的变异下去。</li>
</ol>
</li>
<li><p>主循环后</p>
<ul>
<li><p>fuzz_one 函数</p>
<p>该函数源码在1000多行，出于篇幅原因，我们简要介绍函数的功能。但强烈建议通读该函数源码， 函数主要是从queue中取出entry进行fuzz，成功返回0，跳过或退出的话返回1。</p>
<p>整体过程：</p>
<ol>
<li>根据是否有 <code>pending_favored</code> 和<code>queue_cur</code>的情况，按照概率进行跳过；有<code>pending_favored</code>, 对于已经fuzz过的或者non-favored的有99%的概率跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored；</li>
<li>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case进行测试；</li>
<li>如果测试用例没有修剪过，那么调用函数trim_case对测试用例进行修剪；</li>
<li>修剪完毕之后，使用calculate_score对每个测试用例进行打分；</li>
<li>如果该queue已经完成deterministic阶段，则直接跳到havoc阶段；</li>
<li>deterministic阶段变异4个stage，变异过程中会多次调用函数common_fuzz_stuff函数，保存interesting 的种子：<ul>
<li>bitflip，按位翻转，1变为0，0变为1</li>
<li>arithmetic，整数加/减算术运算</li>
<li>interest，把一些特殊内容替换到原文件中</li>
<li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li>
<li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异。</li>
<li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件。</li>
</ul>
</li>
<li>该轮完成。</li>
</ol>
<p>这里涉及到AFL中的变异策略，不在本次的讨论中，感兴趣的小伙伴可以结合源码自行进行研究。</p>
</li>
<li><p>sync_fuzzers 函数</p>
<p>该函数的主要作用是进行queue同步，先读取有哪些fuzzer文件夹，然后读取其他fuzzer文件夹下的queue文件夹中的测试用例，然后以此执行。如果在执行过程中，发现这些测试用例可以触发新路径，则将测试用例保存到自己的queue文件夹中，并将最后一个同步的测试用例的id写入到 <code>.synced/fuzzer文件夹名</code> 文件中，避免重复运行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="作者有毒的总结"><a href="#作者有毒的总结" class="headerlink" title="作者有毒的总结"></a>作者有毒的总结</h2><p>分析完源码，可以感受到，AFL遵循的基本原则是简单有效，没有进行过多的复杂的优化，能够针对fuzz领域的痛点，对症下药，拒绝花里胡哨，给出切实可行的解决方案，在漏洞挖掘领域的意义的确非同凡响。后期的很多先进的fuzz工具基本沿用了AFL的思路，甚至目前为止已基本围绕AFL建立了“生态圈”，涉及到多个平台、多种漏洞挖掘对象，对于安全研究员来说实属利器，值得从事fuzz相关工作的研究员下足功夫去体会AFL的精髓所在。</p>
<hr>
<p>搬得好累，基础还是太差，看着c语言有种十分陌生的感觉。（菜狗咆哮</p>
<p>找个时间试试怎么使用好了，加油。</p>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AFL%E7%9A%84fuzzer%E2%80%94%E2%80%94afl-fuzz-c"><span class="nav-number">1.1.</span> <span class="nav-text">AFL的fuzzer——afl-fuzz.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text">初始配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%81%8Dfuzz"><span class="nav-number">1.1.2.</span> <span class="nav-text">第一遍fuzz</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.1.3.</span> <span class="nav-text">主循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E8%80%85%E6%9C%89%E6%AF%92%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.</span> <span class="nav-text">作者有毒的总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Anza"
      src="/images/Haida.png">
  <p class="site-author-name" itemprop="name">Anza</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://verf1sh.github.io/" title="https:&#x2F;&#x2F;verf1sh.github.io&#x2F;" rel="noopener" target="_blank">VerF1sh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://4xwi11.github.io/" title="https:&#x2F;&#x2F;4xwi11.github.io&#x2F;" rel="noopener" target="_blank">4XWi11</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="author" itemprop="copyrightHolder">Anza</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
